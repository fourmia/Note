<!--
 * @Author: LiZedong <15516926476@163.com>
 * @Date: 2022-01-08 13:59:56
 * @LastEditors: LiZedong <15516926476@163.com>
 * @LastEditTime: 2022-01-19 15:19:31
 * @FilePath: \A个人笔记\设计模式\单例模式.md
-->
### 单例模式

> 单例模式，也叫单子模式，是一种常用的软件设计模式，属于创建型模式的一种。在应用这个模式时，单例对象的类必须保证只有一个实例存在。许多时候整个系统只需要拥有一个的全局对象，这样有利于我们协调系统整体的行为。（来源于百度百科）举例如下：

+ 服务器上配置文件的读取，由一个单例对象统一读取，其它对象通过单例对象获取配置信息
***

### 使用问题
> 为了避免数据库连接开销，使用**单例模式进行数据库连接**，实现过程出错。由于单例模式中单例对象是将类引用记录下来，则在使用过程中，即使初始化参数不一致，对单例模式来说，其返回的仍为最开始类的参数及引用，从这种情况来说，采用单例模式实现数据库连接，则该程序生命周期中，所连接的数据库无法变更，即使传入其他参数生成实例，但由于单例模式，其检测到有该类的引用会直接进行返回,因此无论传入参数是什么，得到的都是第一次传入参数实例化后的对象。
***
### 用例(读取全局配置文件)
> 由于项目中基本存在一个全局配置文件，所有配置信息均从该配置文件中读取，从这一角度出发，程序生命过程中仅需要一个配置文件读取实例即可，**这样只在第一个实例初始化时解析xml,之后初始化实例其实都指向了该实例，避免了每次初始化实例都需要进行xml解析操作**(个人理解，仅供参考）.
```python
class SingletonMeta(type):

    _instances = {}
    _lock: Lock = Lock()

    def __call__(cls, *args, **kwargs):

        with cls._lock:
            # The first thread to acquire the lock, reaches this conditional,
            # goes inside and creates the Singleton instance. Once it leaves the
            # lock block, a thread that might have been waiting for the lock
            # release may then enter this section. But since the Singleton field
            # is already initialized, the thread won't create a new object.
            if cls not in cls._instances:
                instance = super().__call__(*args, **kwargs)
                cls._instances[cls] = instance
        return cls._instances[cls]


class TestConfig(metaclass=SingletonMeta):
    def __init__(self, para: dict={1:'123'}) -> None:
        self.para = para

>>> t = TestConfig()
>>> t
<__main__.TestConfig object at 0x000002EEAF55CE50>
>>> t.para
{1: '123'}
>>> y = TestConfig({2:'123'})
>>> y
<__main__.TestConfig object at 0x000002EEAF55CE50>
>>> y.para
{1: '123'}
```
