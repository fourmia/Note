<!--
 * @Author: your name
 * @Date: 2021-09-28 10:08:11
 * @LastEditTime: 2021-10-22 13:36:42
 * @LastEditors: Please set LastEditors
 * @Description: 将嵌套列表进行展平并返回
 * @FilePath: \A个人笔记\python相关\常用技巧\嵌套列表展平.md
-->
## 采用递归便捷获取M4各模式数据下全部要素产品路径
### 问题描述
> 西宁短临诊断模块需完成`GRAPES_3KM`下所有数据同步,因此需要构造所有气象要素文件上级目录路径，(如要获取少量要素可直接进行手工构建,对绝大多数目录路径进行手工构建显然不太合理,获取到全部路径后可根据目录特点进行字符串或正则匹配进行排除),可以明确该问题为递归问题，递归的退出条件路径标识不为`D`，这才有了下面工作，此工作建立于`readEC`基础之上，实现代码如下:
> 代码所在位置: `153:/home/cqkj/project/sftp_data/sync_EC/read_xndl_diagnose.py`

```python
import GDS_data_service
import DataBlock_pb2
from logzero import logger
from functools import lru_cache # 缓存先前数据，避免栈深度过大

@lru_cache(maxsize=None)
def get_m4_mdir(dir = r'GRAPES_3KM'):
    """可以获取常用M4中的产品路径，此处获取GRS_3km
    Args:
        dir [str]: 产品类型
    return
        List： 多级嵌套列表
    """
    service = GDS_data_service.GDSDataService(IP, port)
    status, response = service.getFileList(dir)
    print(r'one status:{}'.format(status))
    MappingResult = DataBlock_pb2.MapResult()
    MappingResult.ParseFromString(response)
    results = MappingResult.resultMap
    if next(iter(results.values())) == 'D':
        abs_sub_dirs = ['//'.join([dir,name]) for name,_ in results.items()]
        logger.debug(abs_sub_dirs[:2])
        return [get_m4_mdir(sub) for sub in abs_sub_dirs]
    else:
        return dir
```
> 最终获取结果如下：
```python
['GRAPES_3KM//RAIN06', 'GRAPES_3KM//RAIN12',
['GRAPES_3KM//MAX_VERTICAL_SPEED_SHEAR//600M_ABOVE_GROUND'],
'GRAPES_3KM//RAIN24'...]
```
> 数据获取及转存NC代码依赖`ReadEC`， 在得到目录嵌套列表后需要展平为一维，用于ReadEC模块，展平问题见下分割线
***
### 问题描述
>项目中获取到嵌套序列，为调用已有代码片段，需要对序列元素进行展平，同时不展平字符串，实现效果如下:
```python
from logzero import logger
from collections import Iterable

def flattening_series(items, ignore_types=(str,bytes)):
    pass

input_list = ['dog', ['pig', ['mouse','horse']], 'cat']
unlist =  flattening_series(input_list)
logger.info(f"unlist is:{unlist}")

>>> unlist is:['dog', 'pig', 'mouse', 'horse', 'cat']
```
> 实现的`flattening_series`代码如下,代码来源于 [Python3_Cookbook](https://python3-cookbook.readthedocs.io/zh_CN/latest)：

```python
from logzero import logger
from collections import Iterable

def flattening_series(items, ignore_types=(str, bytes)):
    for x in items:
        if isinstance(x, Iterable) and not isinstance(x, ignore_types):
            logger.debug(f"x_Iterable is:{x}")
            yield from flattening_series(x)    # flattening_series即是委托生成器，也是子生成器， 通过debug进行验证
        else:
            logger.debug(f"only element x is:{x}")
            yield x
```
> 单元测试如下:
```python
import unittest
class TestflatteningSeries(unittest.TestCase):
    def test_nested_series(self):
        self.assertEqual(list(flattening_series(['dog', ['pig', ['mouse','horse']], 'cat'])), ['dog', 'pig', 'mouse', 'horse', 'cat'])
```
> 测试结果如下：
```
[D 210928 11:24:56 嵌套列表展平:19] only element x is:dog
[D 210928 11:24:56 嵌套列表展平:16] x_Iterable is:['pig', ['mouse', 'horse']]
[D 210928 11:24:56 嵌套列表展平:19] only element x is:pig
[D 210928 11:24:56 嵌套列表展平:16] x_Iterable is:['mouse', 'horse']
[D 210928 11:24:56 嵌套列表展平:19] only element x is:mouse
[D 210928 11:24:56 嵌套列表展平:19] only element x is:horse
[D 210928 11:24:56 嵌套列表展平:19] only element x is:cat
.
----------------------------------------------------------------------
Ran 1 test in 0.002s

OK
```

> 完成目录处理后又到了熟悉的数据获取部分，最优方案为多进程加多线程/协程实现，为了方便此处仅给出多进程代码
```python
from logzero import logger,loglevel
from concurrent.futures import ProcessPoolExecutor
loglevel(logging.INFO)

def main(local, all_dir):
    local=local.strftime('%Y%m%d%H')
    svpath=os.path.join(config_.svpath,local[:4]+'.'+local[4:6],local)

    with ProcessPoolExecutor(4) as executor:
        to_do = []
        for sub_dir in flatten(all_dir):
            parent_dir, name = os.path.split(sub_dir)
            path_name = name
            if '/' in parent_dir:
                parent_dir, name_ = os.path.split(parent_dir)
                path_name = '/'.join([name_,name])
            future = executor.submit(main_real, *(parent_dir, path_name, local, svpath, range(0,37,1), path_name))   # main_real 为将数据解析并保存为nc格式， 之后为其所用参数
            #executor.submit(main_real, args=(parent_dir, path_name, local, svpath, range(0,37,1), path_name))
            to_do.append(future)
            logger.debug(f'dir is {sub_dir}:{future}')

        result = []
        for future in futures.as_completed(to_do):
            res = future.result()
            logger.debug(f' {future} result:{res}')
            result.append(res)

```